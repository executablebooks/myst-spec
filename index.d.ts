/* tslint:disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

/**
 * Myst syntax tree built on existing mdast schemas
 */
export type Root = {
  type?: "root";
  /**
   * Top-level children of myst document
   */
  children?: (Block | FlowContent)[] | ListContent[] | PhrasingContent[];
  position?: unknown;
  data?: unknown;
} & Node;
export type Block = {
  type?: "block";
  /**
   * block metadata; conventionally, a stringified JSON dictionary but may be any arbitrary string
   */
  meta?: string;
  /**
   * Top-level children of myst document
   */
  children?: FlowContent[] | ListContent[] | PhrasingContent[];
  position?: unknown;
  data?: unknown;
} & {
  /**
   * identifier for node variant
   */
  type: string;
  /**
   * information associated by the ecosystem with the node; never specified by mdast
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * location of node in source file; must not be present for generated nodes
   */
  position?: {
    /**
     * place of first character of parsed source region
     */
    start: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * place of first character after parsed source region, whether it exists or not
     */
    end: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * start column at each index in the source region, for elements that span multiple lines
     */
    indent?: number;
  };
};
export type FlowContent =
  | Paragraph
  | Definition
  | Heading
  | ThematicBreak
  | Blockquote
  | List
  | HTML
  | Code
  | Comment
  | Target
  | Directive
  | Admonition
  | Container
  | Math
  | Table
  | FootnoteDefinition;
export type Paragraph = {
  type?: "paragraph";
  children?: PhrasingContent[];
  position?: unknown;
  data?: unknown;
} & ({
  children: Node[];
} & {
  /**
   * identifier for node variant
   */
  type: string;
  /**
   * information associated by the ecosystem with the node; never specified by mdast
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * location of node in source file; must not be present for generated nodes
   */
  position?: {
    /**
     * place of first character of parsed source region
     */
    start: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * place of first character after parsed source region, whether it exists or not
     */
    end: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * start column at each index in the source region, for elements that span multiple lines
     */
    indent?: number;
  };
});
export type PhrasingContent =
  | StaticPhrasingContent
  | Emphasis
  | Strong
  | Link
  | LinkReference
  | Subscript
  | Superscript
  | Underline
  | Abbreviation
  | CrossReference
  | FootnoteReference;
export type StaticPhrasingContent =
  | Text
  | HTML
  | EmphasisStatic
  | StrongStatic
  | InlineCode
  | Break
  | Image
  | ImageReference
  | Role
  | SubscriptStatic
  | SuperscriptStatic
  | UnderlineStatic
  | InlineMath;
export type Text = {
  type?: "text";
  value?: unknown;
  position?: unknown;
  data?: unknown;
} & ({
  value: string;
} & {
  /**
   * identifier for node variant
   */
  type: string;
  /**
   * information associated by the ecosystem with the node; never specified by mdast
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * location of node in source file; must not be present for generated nodes
   */
  position?: {
    /**
     * place of first character of parsed source region
     */
    start: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * place of first character after parsed source region, whether it exists or not
     */
    end: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * start column at each index in the source region, for elements that span multiple lines
     */
    indent?: number;
  };
});
/**
 * Fragment of raw HTML - does not need to be valid or complete
 */
export type HTML = {
  type?: "html";
  value?: unknown;
  position?: unknown;
  data?: unknown;
} & ({
  value: string;
} & {
  /**
   * identifier for node variant
   */
  type: string;
  /**
   * information associated by the ecosystem with the node; never specified by mdast
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * location of node in source file; must not be present for generated nodes
   */
  position?: {
    /**
     * place of first character of parsed source region
     */
    start: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * place of first character after parsed source region, whether it exists or not
     */
    end: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * start column at each index in the source region, for elements that span multiple lines
     */
    indent?: number;
  };
});
/**
 * stressed, italicized content, with static children; used when parent node requires static content
 */
export type EmphasisStatic = {
  type?: "emphasis";
  children?: StaticPhrasingContent[];
  position?: unknown;
  data?: unknown;
} & ({
  children: Node[];
} & {
  /**
   * identifier for node variant
   */
  type: string;
  /**
   * information associated by the ecosystem with the node; never specified by mdast
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * location of node in source file; must not be present for generated nodes
   */
  position?: {
    /**
     * place of first character of parsed source region
     */
    start: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * place of first character after parsed source region, whether it exists or not
     */
    end: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * start column at each index in the source region, for elements that span multiple lines
     */
    indent?: number;
  };
});
/**
 * important, serious, urgent, bold content, with static children; used when parent node requires static content
 */
export type StrongStatic = {
  type?: "strong";
  children?: StaticPhrasingContent[];
  position?: unknown;
  data?: unknown;
} & ({
  children: Node[];
} & {
  /**
   * identifier for node variant
   */
  type: string;
  /**
   * information associated by the ecosystem with the node; never specified by mdast
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * location of node in source file; must not be present for generated nodes
   */
  position?: {
    /**
     * place of first character of parsed source region
     */
    start: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * place of first character after parsed source region, whether it exists or not
     */
    end: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * start column at each index in the source region, for elements that span multiple lines
     */
    indent?: number;
  };
});
/**
 * fragment of code
 */
export type InlineCode = {
  type?: "inlineCode";
  value?: unknown;
  position?: unknown;
  data?: unknown;
} & ({
  value: string;
} & {
  /**
   * identifier for node variant
   */
  type: string;
  /**
   * information associated by the ecosystem with the node; never specified by mdast
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * location of node in source file; must not be present for generated nodes
   */
  position?: {
    /**
     * place of first character of parsed source region
     */
    start: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * place of first character after parsed source region, whether it exists or not
     */
    end: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * start column at each index in the source region, for elements that span multiple lines
     */
    indent?: number;
  };
});
/**
 * line break
 */
export type Break = {
  type?: "break";
  position?: unknown;
  data?: unknown;
} & {
  /**
   * identifier for node variant
   */
  type: string;
  /**
   * information associated by the ecosystem with the node; never specified by mdast
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * location of node in source file; must not be present for generated nodes
   */
  position?: {
    /**
     * place of first character of parsed source region
     */
    start: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * place of first character after parsed source region, whether it exists or not
     */
    end: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * start column at each index in the source region, for elements that span multiple lines
     */
    indent?: number;
  };
};
/**
 * image hyperlink
 */
export type Image = {
  type?: "image";
  /**
   * user-defined class for image
   */
  class?: string;
  /**
   * image width in pixels or percentage
   */
  width?: string;
  align?: "left" | "center" | "right";
  url?: unknown;
  title?: unknown;
  alt?: unknown;
  position?: unknown;
  data?: unknown;
} & {
  url: string;
  /**
   * advisory information, e.g. for a tooltip
   */
  title?: string;
} & {
  /**
   * field describing the image
   */
  alt?: string;
} & {
  /**
   * identifier for node variant
   */
  type: string;
  /**
   * information associated by the ecosystem with the node; never specified by mdast
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * location of node in source file; must not be present for generated nodes
   */
  position?: {
    /**
     * place of first character of parsed source region
     */
    start: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * place of first character after parsed source region, whether it exists or not
     */
    end: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * start column at each index in the source region, for elements that span multiple lines
     */
    indent?: number;
  };
};
/**
 * image through association
 */
export type ImageReference = {
  type?: "imageReference";
  referenceType?: unknown;
  identifier?: unknown;
  label?: unknown;
  alt?: unknown;
  position?: unknown;
  data?: unknown;
} & {
  /**
   * explicitness of the reference: shortcut - reference is implicit, identifier inferred; collapsed - refernce explicit, identifier inferred; full - reference explicit, identifier explicit
   */
  referenceType: "shortcut" | "collapsed" | "full";
} & ({
    identifier: unknown;
  } & {
    /**
     * identifier that may match another node; value is unparsed and must be normalized such that whitespace is collapsed to single space, initial/final space is trimmed, and case is folded
     */
    identifier?: string;
    /**
     * node label; character escapes and references are parsed; may be normalized to a unique identifier
     */
    label?: string;
  }) & {
    /**
     * field describing the image
     */
    alt?: string;
  } & {
    /**
     * identifier for node variant
     */
    type: string;
    /**
     * information associated by the ecosystem with the node; never specified by mdast
     */
    data?: {
      [k: string]: unknown;
    };
    /**
     * location of node in source file; must not be present for generated nodes
     */
    position?: {
      /**
       * place of first character of parsed source region
       */
      start: {
        /**
         * line in the source file, 1-indexed
         */
        line: number;
        /**
         * column in the source file, 1-indexed
         */
        column: number;
        /**
         * offset character in the source file, 0-indexed
         */
        offset?: number;
      };
      /**
       * place of first character after parsed source region, whether it exists or not
       */
      end: {
        /**
         * line in the source file, 1-indexed
         */
        line: number;
        /**
         * column in the source file, 1-indexed
         */
        column: number;
        /**
         * offset character in the source file, 0-indexed
         */
        offset?: number;
      };
      /**
       * start column at each index in the source region, for elements that span multiple lines
       */
      indent?: number;
    };
  };
/**
 * myst role in the format {kind}`value`
 */
export type Role = {
  type?: "role";
  kind: string;
  /**
   * content of the directive
   */
  value?: string;
  /**
   * parsed role content
   */
  children?: PhrasingContent[];
  position?: unknown;
  data?: unknown;
} & {
  /**
   * identifier for node variant
   */
  type: string;
  /**
   * information associated by the ecosystem with the node; never specified by mdast
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * location of node in source file; must not be present for generated nodes
   */
  position?: {
    /**
     * place of first character of parsed source region
     */
    start: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * place of first character after parsed source region, whether it exists or not
     */
    end: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * start column at each index in the source region, for elements that span multiple lines
     */
    indent?: number;
  };
};
/**
 * subscript content, with static children; used when parent node requires static content
 */
export type SubscriptStatic = {
  type?: "subscript";
  children?: StaticPhrasingContent[];
  position?: unknown;
  data?: unknown;
} & ({
  children: Node[];
} & {
  /**
   * identifier for node variant
   */
  type: string;
  /**
   * information associated by the ecosystem with the node; never specified by mdast
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * location of node in source file; must not be present for generated nodes
   */
  position?: {
    /**
     * place of first character of parsed source region
     */
    start: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * place of first character after parsed source region, whether it exists or not
     */
    end: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * start column at each index in the source region, for elements that span multiple lines
     */
    indent?: number;
  };
});
/**
 * superscript content, with static children; used when parent node requires static content
 */
export type SuperscriptStatic = {
  type?: "superscript";
  children?: StaticPhrasingContent[];
  position?: unknown;
  data?: unknown;
} & ({
  children: Node[];
} & {
  /**
   * identifier for node variant
   */
  type: string;
  /**
   * information associated by the ecosystem with the node; never specified by mdast
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * location of node in source file; must not be present for generated nodes
   */
  position?: {
    /**
     * place of first character of parsed source region
     */
    start: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * place of first character after parsed source region, whether it exists or not
     */
    end: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * start column at each index in the source region, for elements that span multiple lines
     */
    indent?: number;
  };
});
/**
 * underline content, with static children; used when parent node requires static content
 */
export type UnderlineStatic = {
  type?: "underline";
  children?: StaticPhrasingContent[];
  position?: unknown;
  data?: unknown;
} & ({
  children: Node[];
} & {
  /**
   * identifier for node variant
   */
  type: string;
  /**
   * information associated by the ecosystem with the node; never specified by mdast
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * location of node in source file; must not be present for generated nodes
   */
  position?: {
    /**
     * place of first character of parsed source region
     */
    start: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * place of first character after parsed source region, whether it exists or not
     */
    end: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * start column at each index in the source region, for elements that span multiple lines
     */
    indent?: number;
  };
});
/**
 * fragment of math, similar to InlineCode, using role {math}
 */
export type InlineMath = {
  type?: "inlineMath";
  value?: unknown;
  position?: unknown;
  data?: unknown;
} & ({
  value: string;
} & {
  /**
   * identifier for node variant
   */
  type: string;
  /**
   * information associated by the ecosystem with the node; never specified by mdast
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * location of node in source file; must not be present for generated nodes
   */
  position?: {
    /**
     * place of first character of parsed source region
     */
    start: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * place of first character after parsed source region, whether it exists or not
     */
    end: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * start column at each index in the source region, for elements that span multiple lines
     */
    indent?: number;
  };
});
/**
 * stressed, italicized content
 */
export type Emphasis = {
  type?: "emphasis";
  children?: PhrasingContent[];
  position?: unknown;
  data?: unknown;
} & ({
  children: Node[];
} & {
  /**
   * identifier for node variant
   */
  type: string;
  /**
   * information associated by the ecosystem with the node; never specified by mdast
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * location of node in source file; must not be present for generated nodes
   */
  position?: {
    /**
     * place of first character of parsed source region
     */
    start: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * place of first character after parsed source region, whether it exists or not
     */
    end: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * start column at each index in the source region, for elements that span multiple lines
     */
    indent?: number;
  };
});
/**
 * important, serious, urgent, bold content
 */
export type Strong = {
  type?: "strong";
  children?: PhrasingContent[];
  position?: unknown;
  data?: unknown;
} & ({
  children: Node[];
} & {
  /**
   * identifier for node variant
   */
  type: string;
  /**
   * information associated by the ecosystem with the node; never specified by mdast
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * location of node in source file; must not be present for generated nodes
   */
  position?: {
    /**
     * place of first character of parsed source region
     */
    start: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * place of first character after parsed source region, whether it exists or not
     */
    end: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * start column at each index in the source region, for elements that span multiple lines
     */
    indent?: number;
  };
});
/**
 * hyperlink
 */
export type Link = {
  type?: "link";
  children?: StaticPhrasingContent[];
  url?: unknown;
  title?: unknown;
  position?: unknown;
  data?: unknown;
} & {
  url: string;
  /**
   * advisory information, e.g. for a tooltip
   */
  title?: string;
} & ({
    children: Node[];
  } & {
    /**
     * identifier for node variant
     */
    type: string;
    /**
     * information associated by the ecosystem with the node; never specified by mdast
     */
    data?: {
      [k: string]: unknown;
    };
    /**
     * location of node in source file; must not be present for generated nodes
     */
    position?: {
      /**
       * place of first character of parsed source region
       */
      start: {
        /**
         * line in the source file, 1-indexed
         */
        line: number;
        /**
         * column in the source file, 1-indexed
         */
        column: number;
        /**
         * offset character in the source file, 0-indexed
         */
        offset?: number;
      };
      /**
       * place of first character after parsed source region, whether it exists or not
       */
      end: {
        /**
         * line in the source file, 1-indexed
         */
        line: number;
        /**
         * column in the source file, 1-indexed
         */
        column: number;
        /**
         * offset character in the source file, 0-indexed
         */
        offset?: number;
      };
      /**
       * start column at each index in the source region, for elements that span multiple lines
       */
      indent?: number;
    };
  });
/**
 * hyperlink through association
 */
export type LinkReference = {
  type?: "linkReference";
  children?: StaticPhrasingContent[];
  referenceType?: unknown;
  identifier?: unknown;
  label?: unknown;
  position?: unknown;
  data?: unknown;
} & {
  /**
   * explicitness of the reference: shortcut - reference is implicit, identifier inferred; collapsed - refernce explicit, identifier inferred; full - reference explicit, identifier explicit
   */
  referenceType: "shortcut" | "collapsed" | "full";
} & ({
    identifier: unknown;
  } & {
    /**
     * identifier that may match another node; value is unparsed and must be normalized such that whitespace is collapsed to single space, initial/final space is trimmed, and case is folded
     */
    identifier?: string;
    /**
     * node label; character escapes and references are parsed; may be normalized to a unique identifier
     */
    label?: string;
  }) &
  ({
    children: Node[];
  } & {
    /**
     * identifier for node variant
     */
    type: string;
    /**
     * information associated by the ecosystem with the node; never specified by mdast
     */
    data?: {
      [k: string]: unknown;
    };
    /**
     * location of node in source file; must not be present for generated nodes
     */
    position?: {
      /**
       * place of first character of parsed source region
       */
      start: {
        /**
         * line in the source file, 1-indexed
         */
        line: number;
        /**
         * column in the source file, 1-indexed
         */
        column: number;
        /**
         * offset character in the source file, 0-indexed
         */
        offset?: number;
      };
      /**
       * place of first character after parsed source region, whether it exists or not
       */
      end: {
        /**
         * line in the source file, 1-indexed
         */
        line: number;
        /**
         * column in the source file, 1-indexed
         */
        column: number;
        /**
         * offset character in the source file, 0-indexed
         */
        offset?: number;
      };
      /**
       * start column at each index in the source region, for elements that span multiple lines
       */
      indent?: number;
    };
  });
/**
 * subscript content, using role {subscript}
 */
export type Subscript = {
  type?: "subscript";
  children?: PhrasingContent[];
  position?: unknown;
  data?: unknown;
} & ({
  children: Node[];
} & {
  /**
   * identifier for node variant
   */
  type: string;
  /**
   * information associated by the ecosystem with the node; never specified by mdast
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * location of node in source file; must not be present for generated nodes
   */
  position?: {
    /**
     * place of first character of parsed source region
     */
    start: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * place of first character after parsed source region, whether it exists or not
     */
    end: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * start column at each index in the source region, for elements that span multiple lines
     */
    indent?: number;
  };
});
/**
 * superscript content, using role {superscript}
 */
export type Superscript = {
  type?: "superscript";
  children?: PhrasingContent[];
  position?: unknown;
  data?: unknown;
} & ({
  children: Node[];
} & {
  /**
   * identifier for node variant
   */
  type: string;
  /**
   * information associated by the ecosystem with the node; never specified by mdast
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * location of node in source file; must not be present for generated nodes
   */
  position?: {
    /**
     * place of first character of parsed source region
     */
    start: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * place of first character after parsed source region, whether it exists or not
     */
    end: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * start column at each index in the source region, for elements that span multiple lines
     */
    indent?: number;
  };
});
/**
 * underline content, using role {underline}
 */
export type Underline = {
  type?: "underline";
  children?: PhrasingContent[];
  position?: unknown;
  data?: unknown;
} & ({
  children: Node[];
} & {
  /**
   * identifier for node variant
   */
  type: string;
  /**
   * information associated by the ecosystem with the node; never specified by mdast
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * location of node in source file; must not be present for generated nodes
   */
  position?: {
    /**
     * place of first character of parsed source region
     */
    start: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * place of first character after parsed source region, whether it exists or not
     */
    end: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * start column at each index in the source region, for elements that span multiple lines
     */
    indent?: number;
  };
});
/**
 * abbreviation described by title, using role {abbr}
 */
export type Abbreviation = {
  type?: "abbreviation";
  children?: AbbreviatedValue;
  /**
   * advisory information for the abbreviation
   */
  title?: string;
  position?: unknown;
  data?: unknown;
} & ({
  children: Node[];
} & {
  /**
   * identifier for node variant
   */
  type: string;
  /**
   * information associated by the ecosystem with the node; never specified by mdast
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * location of node in source file; must not be present for generated nodes
   */
  position?: {
    /**
     * place of first character of parsed source region
     */
    start: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * place of first character after parsed source region, whether it exists or not
     */
    end: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * start column at each index in the source region, for elements that span multiple lines
     */
    indent?: number;
  };
});
export type AbbreviatedValue = StaticPhrasingContent[];
/**
 * reference to associated node, using role {eq}, {ref}, {numref}
 */
export type CrossReference = {
  type?: "crossReference";
  kind?: "eq" | "numref" | "ref";
  children?: StaticPhrasingContent[];
  identifier?: unknown;
  label?: unknown;
  position?: unknown;
  data?: unknown;
} & ({
  identifier: unknown;
} & {
  /**
   * identifier that may match another node; value is unparsed and must be normalized such that whitespace is collapsed to single space, initial/final space is trimmed, and case is folded
   */
  identifier?: string;
  /**
   * node label; character escapes and references are parsed; may be normalized to a unique identifier
   */
  label?: string;
}) & {
    /**
     * identifier for node variant
     */
    type: string;
    /**
     * information associated by the ecosystem with the node; never specified by mdast
     */
    data?: {
      [k: string]: unknown;
    };
    /**
     * location of node in source file; must not be present for generated nodes
     */
    position?: {
      /**
       * place of first character of parsed source region
       */
      start: {
        /**
         * line in the source file, 1-indexed
         */
        line: number;
        /**
         * column in the source file, 1-indexed
         */
        column: number;
        /**
         * offset character in the source file, 0-indexed
         */
        offset?: number;
      };
      /**
       * place of first character after parsed source region, whether it exists or not
       */
      end: {
        /**
         * line in the source file, 1-indexed
         */
        line: number;
        /**
         * column in the source file, 1-indexed
         */
        column: number;
        /**
         * offset character in the source file, 0-indexed
         */
        offset?: number;
      };
      /**
       * start column at each index in the source region, for elements that span multiple lines
       */
      indent?: number;
    };
  };
/**
 * Inilne reference to footnote
 */
export type FootnoteReference = {
  type?: "footnoteReference";
  identifier?: unknown;
  label?: unknown;
  position?: unknown;
  data?: unknown;
} & ({
  identifier: unknown;
} & {
  /**
   * identifier that may match another node; value is unparsed and must be normalized such that whitespace is collapsed to single space, initial/final space is trimmed, and case is folded
   */
  identifier?: string;
  /**
   * node label; character escapes and references are parsed; may be normalized to a unique identifier
   */
  label?: string;
}) & {
    /**
     * identifier for node variant
     */
    type: string;
    /**
     * information associated by the ecosystem with the node; never specified by mdast
     */
    data?: {
      [k: string]: unknown;
    };
    /**
     * location of node in source file; must not be present for generated nodes
     */
    position?: {
      /**
       * place of first character of parsed source region
       */
      start: {
        /**
         * line in the source file, 1-indexed
         */
        line: number;
        /**
         * column in the source file, 1-indexed
         */
        column: number;
        /**
         * offset character in the source file, 0-indexed
         */
        offset?: number;
      };
      /**
       * place of first character after parsed source region, whether it exists or not
       */
      end: {
        /**
         * line in the source file, 1-indexed
         */
        line: number;
        /**
         * column in the source file, 1-indexed
         */
        column: number;
        /**
         * offset character in the source file, 0-indexed
         */
        offset?: number;
      };
      /**
       * start column at each index in the source region, for elements that span multiple lines
       */
      indent?: number;
    };
  };
/**
 * reference to a url resource
 */
export type Definition = {
  type?: "definition";
  identifier?: unknown;
  label?: unknown;
  url?: unknown;
  title?: unknown;
  position?: unknown;
  data?: unknown;
} & ({
  identifier: unknown;
} & {
  /**
   * identifier that may match another node; value is unparsed and must be normalized such that whitespace is collapsed to single space, initial/final space is trimmed, and case is folded
   */
  identifier?: string;
  /**
   * node label; character escapes and references are parsed; may be normalized to a unique identifier
   */
  label?: string;
}) & {
    url: string;
    /**
     * advisory information, e.g. for a tooltip
     */
    title?: string;
  } & {
    /**
     * identifier for node variant
     */
    type: string;
    /**
     * information associated by the ecosystem with the node; never specified by mdast
     */
    data?: {
      [k: string]: unknown;
    };
    /**
     * location of node in source file; must not be present for generated nodes
     */
    position?: {
      /**
       * place of first character of parsed source region
       */
      start: {
        /**
         * line in the source file, 1-indexed
         */
        line: number;
        /**
         * column in the source file, 1-indexed
         */
        column: number;
        /**
         * offset character in the source file, 0-indexed
         */
        offset?: number;
      };
      /**
       * place of first character after parsed source region, whether it exists or not
       */
      end: {
        /**
         * line in the source file, 1-indexed
         */
        line: number;
        /**
         * column in the source file, 1-indexed
         */
        column: number;
        /**
         * offset character in the source file, 0-indexed
         */
        offset?: number;
      };
      /**
       * start column at each index in the source region, for elements that span multiple lines
       */
      indent?: number;
    };
  };
export type Heading = {
  type?: "heading";
  depth: number;
  children?: PhrasingContent[];
  identifier?: unknown;
  label?: unknown;
  position?: unknown;
  data?: unknown;
} & ({
  children: Node[];
} & {
  /**
   * identifier for node variant
   */
  type: string;
  /**
   * information associated by the ecosystem with the node; never specified by mdast
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * location of node in source file; must not be present for generated nodes
   */
  position?: {
    /**
     * place of first character of parsed source region
     */
    start: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * place of first character after parsed source region, whether it exists or not
     */
    end: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * start column at each index in the source region, for elements that span multiple lines
     */
    indent?: number;
  };
}) & {
    /**
     * identifier that may match another node; value is unparsed and must be normalized such that whitespace is collapsed to single space, initial/final space is trimmed, and case is folded
     */
    identifier?: string;
    /**
     * node label; character escapes and references are parsed; may be normalized to a unique identifier
     */
    label?: string;
  };
export type ThematicBreak = {
  type?: "thematicBreak";
  position?: unknown;
  data?: unknown;
} & {
  /**
   * identifier for node variant
   */
  type: string;
  /**
   * information associated by the ecosystem with the node; never specified by mdast
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * location of node in source file; must not be present for generated nodes
   */
  position?: {
    /**
     * place of first character of parsed source region
     */
    start: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * place of first character after parsed source region, whether it exists or not
     */
    end: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * start column at each index in the source region, for elements that span multiple lines
     */
    indent?: number;
  };
};
export type Blockquote = {
  type?: "blockquote";
  children?: FlowContent[];
  position?: unknown;
  data?: unknown;
} & ({
  children: Node[];
} & {
  /**
   * identifier for node variant
   */
  type: string;
  /**
   * information associated by the ecosystem with the node; never specified by mdast
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * location of node in source file; must not be present for generated nodes
   */
  position?: {
    /**
     * place of first character of parsed source region
     */
    start: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * place of first character after parsed source region, whether it exists or not
     */
    end: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * start column at each index in the source region, for elements that span multiple lines
     */
    indent?: number;
  };
});
export type List = {
  type?: "list";
  /**
   * Is item order important or not?
   */
  ordered?: boolean;
  /**
   * Starting number of ordered list
   */
  start?: number;
  /**
   * One or more children are separated with a blank line from others
   */
  spread?: boolean;
  children?: ListContent[];
  position?: unknown;
  data?: unknown;
} & ({
  children: Node[];
} & {
  /**
   * identifier for node variant
   */
  type: string;
  /**
   * information associated by the ecosystem with the node; never specified by mdast
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * location of node in source file; must not be present for generated nodes
   */
  position?: {
    /**
     * place of first character of parsed source region
     */
    start: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * place of first character after parsed source region, whether it exists or not
     */
    end: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * start column at each index in the source region, for elements that span multiple lines
     */
    indent?: number;
  };
});
export type ListContent = ListItem;
export type ListItem = {
  type?: "listItem";
  /**
   * One or more children are separated with a blank line from others
   */
  spread?: boolean;
  children?: (PhrasingContent | FlowContent)[];
  position?: unknown;
  data?: unknown;
} & ({
  children: Node[];
} & {
  /**
   * identifier for node variant
   */
  type: string;
  /**
   * information associated by the ecosystem with the node; never specified by mdast
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * location of node in source file; must not be present for generated nodes
   */
  position?: {
    /**
     * place of first character of parsed source region
     */
    start: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * place of first character after parsed source region, whether it exists or not
     */
    end: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * start column at each index in the source region, for elements that span multiple lines
     */
    indent?: number;
  };
});
/**
 * block of preformatted text
 */
export type Code = {
  type?: "code";
  /**
   * language of the code
   */
  lang?: string;
  /**
   * custom information relating to the node
   */
  meta?: string;
  /**
   * user-defined class for code block
   */
  class?: string;
  showLineNumbers?: boolean;
  startingLineNumber?: number;
  emphasizeLines?: number[];
  identifier?: unknown;
  label?: unknown;
  value?: unknown;
  position?: unknown;
  data?: unknown;
} & {} & {} & {
  /**
   * identifier that may match another node; value is unparsed and must be normalized such that whitespace is collapsed to single space, initial/final space is trimmed, and case is folded
   */
  identifier?: string;
  /**
   * node label; character escapes and references are parsed; may be normalized to a unique identifier
   */
  label?: string;
} & ({
    value: string;
  } & {
    /**
     * identifier for node variant
     */
    type: string;
    /**
     * information associated by the ecosystem with the node; never specified by mdast
     */
    data?: {
      [k: string]: unknown;
    };
    /**
     * location of node in source file; must not be present for generated nodes
     */
    position?: {
      /**
       * place of first character of parsed source region
       */
      start: {
        /**
         * line in the source file, 1-indexed
         */
        line: number;
        /**
         * column in the source file, 1-indexed
         */
        column: number;
        /**
         * offset character in the source file, 0-indexed
         */
        offset?: number;
      };
      /**
       * place of first character after parsed source region, whether it exists or not
       */
      end: {
        /**
         * line in the source file, 1-indexed
         */
        line: number;
        /**
         * column in the source file, 1-indexed
         */
        column: number;
        /**
         * offset character in the source file, 0-indexed
         */
        offset?: number;
      };
      /**
       * start column at each index in the source region, for elements that span multiple lines
       */
      indent?: number;
    };
  });
export type Comment = {
  type?: "comment";
  value?: unknown;
  position?: unknown;
  data?: unknown;
} & ({
  value: string;
} & {
  /**
   * identifier for node variant
   */
  type: string;
  /**
   * information associated by the ecosystem with the node; never specified by mdast
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * location of node in source file; must not be present for generated nodes
   */
  position?: {
    /**
     * place of first character of parsed source region
     */
    start: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * place of first character after parsed source region, whether it exists or not
     */
    end: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * start column at each index in the source region, for elements that span multiple lines
     */
    indent?: number;
  };
});
export type Target = {
  type?: "target";
  identifier?: unknown;
  label?: unknown;
  position?: unknown;
  data?: unknown;
} & {
  /**
   * identifier for node variant
   */
  type: string;
  /**
   * information associated by the ecosystem with the node; never specified by mdast
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * location of node in source file; must not be present for generated nodes
   */
  position?: {
    /**
     * place of first character of parsed source region
     */
    start: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * place of first character after parsed source region, whether it exists or not
     */
    end: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * start column at each index in the source region, for elements that span multiple lines
     */
    indent?: number;
  };
} & ({
    identifier: unknown;
  } & {
    /**
     * identifier that may match another node; value is unparsed and must be normalized such that whitespace is collapsed to single space, initial/final space is trimmed, and case is folded
     */
    identifier?: string;
    /**
     * node label; character escapes and references are parsed; may be normalized to a unique identifier
     */
    label?: string;
  });
/**
 * myst directive, in the format ```{kind} args
 *
 * :options:
 *
 * value
 * ```
 */
export type Directive = {
  type?: "directive";
  kind: string;
  args?: string;
  options?: {
    [k: string]: unknown;
  };
  /**
   * body of the directive, excluding options
   */
  value?: string;
  /**
   * parsed directive content
   */
  children?: (FlowContent | PhrasingContent)[];
  position?: unknown;
  data?: unknown;
} & {
  /**
   * identifier for node variant
   */
  type: string;
  /**
   * information associated by the ecosystem with the node; never specified by mdast
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * location of node in source file; must not be present for generated nodes
   */
  position?: {
    /**
     * place of first character of parsed source region
     */
    start: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * place of first character after parsed source region, whether it exists or not
     */
    end: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * start column at each index in the source region, for elements that span multiple lines
     */
    indent?: number;
  };
};
/**
 * highlighted block of text slightly separated from neighboring content
 */
export type Admonition = {
  type?: "admonition";
  /**
   * kind of admonition, to determine styling
   */
  kind?: "attention" | "caution" | "danger" | "error" | "hint" | "important" | "note" | "seealso" | "tip" | "warning";
  /**
   * admonition class info to override kind
   */
  class?: string;
  children?: (AdmonitionTitle | FlowContent)[];
  position?: unknown;
  data?: unknown;
} & {
  /**
   * identifier for node variant
   */
  type: string;
  /**
   * information associated by the ecosystem with the node; never specified by mdast
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * location of node in source file; must not be present for generated nodes
   */
  position?: {
    /**
     * place of first character of parsed source region
     */
    start: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * place of first character after parsed source region, whether it exists or not
     */
    end: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * start column at each index in the source region, for elements that span multiple lines
     */
    indent?: number;
  };
};
/**
 * custom title for admonition, replaces kind as title
 */
export type AdmonitionTitle = {
  type?: "admonitionTitle";
  children?: PhrasingContent[];
  position?: unknown;
  data?: unknown;
} & ({
  children: Node[];
} & {
  /**
   * identifier for node variant
   */
  type: string;
  /**
   * information associated by the ecosystem with the node; never specified by mdast
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * location of node in source file; must not be present for generated nodes
   */
  position?: {
    /**
     * place of first character of parsed source region
     */
    start: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * place of first character after parsed source region, whether it exists or not
     */
    end: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * start column at each index in the source region, for elements that span multiple lines
     */
    indent?: number;
  };
});
/**
 * top-level container node to provide association and numbering to child content
 */
export type Container = {
  type?: "container";
  /**
   * kind of container contents
   */
  kind: "figure" | "table";
  /**
   * any custom class information
   */
  class?: string;
  /**
   * count this container for numbering based on kind, e.g. Figure 1
   */
  numbered?: boolean;
  children?: (Caption | Legend | Image | Table)[];
  identifier?: unknown;
  label?: unknown;
  position?: unknown;
  data?: unknown;
} & {} & {
  /**
   * identifier that may match another node; value is unparsed and must be normalized such that whitespace is collapsed to single space, initial/final space is trimmed, and case is folded
   */
  identifier?: string;
  /**
   * node label; character escapes and references are parsed; may be normalized to a unique identifier
   */
  label?: string;
} & ({
    children: Node[];
  } & {
    /**
     * identifier for node variant
     */
    type: string;
    /**
     * information associated by the ecosystem with the node; never specified by mdast
     */
    data?: {
      [k: string]: unknown;
    };
    /**
     * location of node in source file; must not be present for generated nodes
     */
    position?: {
      /**
       * place of first character of parsed source region
       */
      start: {
        /**
         * line in the source file, 1-indexed
         */
        line: number;
        /**
         * column in the source file, 1-indexed
         */
        column: number;
        /**
         * offset character in the source file, 0-indexed
         */
        offset?: number;
      };
      /**
       * place of first character after parsed source region, whether it exists or not
       */
      end: {
        /**
         * line in the source file, 1-indexed
         */
        line: number;
        /**
         * column in the source file, 1-indexed
         */
        column: number;
        /**
         * offset character in the source file, 0-indexed
         */
        offset?: number;
      };
      /**
       * start column at each index in the source region, for elements that span multiple lines
       */
      indent?: number;
    };
  });
/**
 * caption for container content
 */
export type Caption = {
  type?: "caption";
  children?: FlowContent[];
  position?: unknown;
  data?: unknown;
} & ({
  children: Node[];
} & {
  /**
   * identifier for node variant
   */
  type: string;
  /**
   * information associated by the ecosystem with the node; never specified by mdast
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * location of node in source file; must not be present for generated nodes
   */
  position?: {
    /**
     * place of first character of parsed source region
     */
    start: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * place of first character after parsed source region, whether it exists or not
     */
    end: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * start column at each index in the source region, for elements that span multiple lines
     */
    indent?: number;
  };
});
/**
 * legend for container content
 */
export type Legend = {
  type?: "legend";
  children?: FlowContent[];
  position?: unknown;
  data?: unknown;
} & ({
  children: Node[];
} & {
  /**
   * identifier for node variant
   */
  type: string;
  /**
   * information associated by the ecosystem with the node; never specified by mdast
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * location of node in source file; must not be present for generated nodes
   */
  position?: {
    /**
     * place of first character of parsed source region
     */
    start: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * place of first character after parsed source region, whether it exists or not
     */
    end: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * start column at each index in the source region, for elements that span multiple lines
     */
    indent?: number;
  };
});
/**
 * two-dimensional table data
 */
export type Table = {
  type?: "table";
  align?: "left" | "center" | "right";
  children?: TableRow[];
  position?: unknown;
  data?: unknown;
} & ({
  children: Node[];
} & {
  /**
   * identifier for node variant
   */
  type: string;
  /**
   * information associated by the ecosystem with the node; never specified by mdast
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * location of node in source file; must not be present for generated nodes
   */
  position?: {
    /**
     * place of first character of parsed source region
     */
    start: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * place of first character after parsed source region, whether it exists or not
     */
    end: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * start column at each index in the source region, for elements that span multiple lines
     */
    indent?: number;
  };
});
/**
 * one row of table containing cells
 */
export type TableRow = {
  type?: "tableRow";
  children?: TableCell[];
  position?: unknown;
  data?: unknown;
} & ({
  children: Node[];
} & {
  /**
   * identifier for node variant
   */
  type: string;
  /**
   * information associated by the ecosystem with the node; never specified by mdast
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * location of node in source file; must not be present for generated nodes
   */
  position?: {
    /**
     * place of first character of parsed source region
     */
    start: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * place of first character after parsed source region, whether it exists or not
     */
    end: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * start column at each index in the source region, for elements that span multiple lines
     */
    indent?: number;
  };
});
/**
 * one cell of table
 */
export type TableCell = {
  type?: "tableCell";
  header?: boolean;
  /**
   * alignment of content within cell
   */
  align?: "left" | "center" | "right";
  children?: PhrasingContent[];
  position?: unknown;
  data?: unknown;
} & ({
  children: Node[];
} & {
  /**
   * identifier for node variant
   */
  type: string;
  /**
   * information associated by the ecosystem with the node; never specified by mdast
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * location of node in source file; must not be present for generated nodes
   */
  position?: {
    /**
     * place of first character of parsed source region
     */
    start: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * place of first character after parsed source region, whether it exists or not
     */
    end: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * start column at each index in the source region, for elements that span multiple lines
     */
    indent?: number;
  };
});
/**
 * block of math
 */
export type Math = {
  type?: "math";
  identifier?: unknown;
  label?: unknown;
  value?: unknown;
  position?: unknown;
  data?: unknown;
} & {
  /**
   * identifier that may match another node; value is unparsed and must be normalized such that whitespace is collapsed to single space, initial/final space is trimmed, and case is folded
   */
  identifier?: string;
  /**
   * node label; character escapes and references are parsed; may be normalized to a unique identifier
   */
  label?: string;
} & ({
    value: string;
  } & {
    /**
     * identifier for node variant
     */
    type: string;
    /**
     * information associated by the ecosystem with the node; never specified by mdast
     */
    data?: {
      [k: string]: unknown;
    };
    /**
     * location of node in source file; must not be present for generated nodes
     */
    position?: {
      /**
       * place of first character of parsed source region
       */
      start: {
        /**
         * line in the source file, 1-indexed
         */
        line: number;
        /**
         * column in the source file, 1-indexed
         */
        column: number;
        /**
         * offset character in the source file, 0-indexed
         */
        offset?: number;
      };
      /**
       * place of first character after parsed source region, whether it exists or not
       */
      end: {
        /**
         * line in the source file, 1-indexed
         */
        line: number;
        /**
         * column in the source file, 1-indexed
         */
        column: number;
        /**
         * offset character in the source file, 0-indexed
         */
        offset?: number;
      };
      /**
       * start column at each index in the source region, for elements that span multiple lines
       */
      indent?: number;
    };
  });
/**
 * Rich footnote content associated with footnote reference
 */
export type FootnoteDefinition = {
  type?: "footnoteDefinition";
  children?: FlowContent[];
  identifier?: unknown;
  label?: unknown;
  position?: unknown;
  data?: unknown;
} & ({
  identifier: unknown;
} & {
  /**
   * identifier that may match another node; value is unparsed and must be normalized such that whitespace is collapsed to single space, initial/final space is trimmed, and case is folded
   */
  identifier?: string;
  /**
   * node label; character escapes and references are parsed; may be normalized to a unique identifier
   */
  label?: string;
}) &
  ({
    children: Node[];
  } & {
    /**
     * identifier for node variant
     */
    type: string;
    /**
     * information associated by the ecosystem with the node; never specified by mdast
     */
    data?: {
      [k: string]: unknown;
    };
    /**
     * location of node in source file; must not be present for generated nodes
     */
    position?: {
      /**
       * place of first character of parsed source region
       */
      start: {
        /**
         * line in the source file, 1-indexed
         */
        line: number;
        /**
         * column in the source file, 1-indexed
         */
        column: number;
        /**
         * offset character in the source file, 0-indexed
         */
        offset?: number;
      };
      /**
       * place of first character after parsed source region, whether it exists or not
       */
      end: {
        /**
         * line in the source file, 1-indexed
         */
        line: number;
        /**
         * column in the source file, 1-indexed
         */
        column: number;
        /**
         * offset character in the source file, 0-indexed
         */
        offset?: number;
      };
      /**
       * start column at each index in the source region, for elements that span multiple lines
       */
      indent?: number;
    };
  });

/**
 * base unist node
 */
export interface Node {
  /**
   * identifier for node variant
   */
  type: string;
  /**
   * information associated by the ecosystem with the node; never specified by mdast
   */
  data?: {
    [k: string]: unknown;
  };
  /**
   * location of node in source file; must not be present for generated nodes
   */
  position?: {
    /**
     * place of first character of parsed source region
     */
    start: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * place of first character after parsed source region, whether it exists or not
     */
    end: {
      /**
       * line in the source file, 1-indexed
       */
      line: number;
      /**
       * column in the source file, 1-indexed
       */
      column: number;
      /**
       * offset character in the source file, 0-indexed
       */
      offset?: number;
    };
    /**
     * start column at each index in the source region, for elements that span multiple lines
     */
    indent?: number;
  };
}
